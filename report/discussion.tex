\section{Discussion}\label{sec:discussion}

% - testing the algorithm on real hardware was limited... But we have a solution.
As mentioned in the previous section, testing on real hardware was limited by the Azure queuing system and the cost of matching our local simulation would be staggering.
Therefore, we deemed further optimization in this avenue out of scope for the project.
However, here, we will present how the queuing could be exploited to speed up testing on real hardware.
Instead of queuing one circuit at a time, one would queue all circuits needed for all tests at the same time.
This is still an insane amount of circuits, especially because individual tests can't be short-circuited when a solution is found.
Therefore, it might be the case that we are still not able to match the scale of the simulation on real hardware with this approach.

% - State vector simulations where inspiring especially when running it twice... Errors might be explainable also.
The local simulations inspired confidence in the algorithm, especially when it was run twice.
In particular, we observed a failure rate of $0.0009\%$ when running the algorithm twice, and a failure rate of $0.0518\%$ when running it once.

% - Rigettis Simulations were not inspiring confidence... Maybe there is an explanation.
As mentioned, we also tested our algorithm on the Rigetti hardware simulator, as it was free and queue times were less punishing there.
Yet, because of queuing times, we where still not able to match the scale of the simulation.
Furthermore, the results were less inspiring than the state vector simulations.
In particular, we observed a failure rate of $0.3636\%$ when running the algorithm twice, and a failure rate of $2\%$ when running it once.
We think that the reason that the results are worse on the Rigetti hardware simulator is because it models noise, yet we were unable to verify this in Azure's documentation.

% - The algorithm seems to work for very small propositions, both in terms of size and running time we are nowhere near beating any mainstream SAT solvers.
Our implementation seems to be working as intended, however only for very small propositions, and with a horrendous running time and cost, in ideal noiseless conditions.
For comparison of the size of problem that classical SAT solvers are able to solve: SATLIB~\cite{hoos2000satlib} contains problems with 250 variables and 1065 clauses.
